import BoundingSphere from"./BoundingSphere.js";import Cartesian2 from"./Cartesian2.js";import Cartesian3 from"./Cartesian3.js";import Cartographic from"./Cartographic.js";import Check from"./Check.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import EllipsoidTangentPlane from"./EllipsoidTangentPlane.js";import Intersect from"./Intersect.js";import Interval from"./Interval.js";import CesiumMath from"./Math.js";import Matrix3 from"./Matrix3.js";import Plane from"./Plane.js";import Rectangle from"./Rectangle.js";function OrientedBoundingBox(e,a){this.center=Cartesian3.clone(defaultValue(e,Cartesian3.ZERO)),this.halfAxes=Matrix3.clone(defaultValue(a,Matrix3.ZERO))}OrientedBoundingBox.packedLength=Cartesian3.packedLength+Matrix3.packedLength,OrientedBoundingBox.pack=function(e,a,r){return Check.typeOf.object("value",e),Check.defined("array",a),r=defaultValue(r,0),Cartesian3.pack(e.center,a,r),Matrix3.pack(e.halfAxes,a,r+Cartesian3.packedLength),a},OrientedBoundingBox.unpack=function(e,a,r){return Check.defined("array",e),a=defaultValue(a,0),defined(r)||(r=new OrientedBoundingBox),Cartesian3.unpack(e,a,r.center),Matrix3.unpack(e,a+Cartesian3.packedLength,r.halfAxes),r};var scratchCartesian1=new Cartesian3,scratchCartesian2=new Cartesian3,scratchCartesian3=new Cartesian3,scratchCartesian4=new Cartesian3,scratchCartesian5=new Cartesian3,scratchCartesian6=new Cartesian3,scratchCovarianceResult=new Matrix3,scratchEigenResult={unitary:new Matrix3,diagonal:new Matrix3};OrientedBoundingBox.fromPoints=function(e,a){if(defined(a)||(a=new OrientedBoundingBox),!defined(e)||0===e.length)return a.halfAxes=Matrix3.ZERO,a.center=Cartesian3.ZERO,a;var r,t=e.length,n=Cartesian3.clone(e[0],scratchCartesian1);for(r=1;r<t;r++)Cartesian3.add(n,e[r],n);var i=1/t;Cartesian3.multiplyByScalar(n,i,n);var s,c=0,o=0,d=0,C=0,h=0,u=0;for(r=0;r<t;r++)c+=(s=Cartesian3.subtract(e[r],n,scratchCartesian2)).x*s.x,o+=s.x*s.y,d+=s.x*s.z,C+=s.y*s.y,h+=s.y*s.z,u+=s.z*s.z;c*=i,o*=i,d*=i,C*=i,h*=i,u*=i;var l=scratchCovarianceResult;l[0]=c,l[1]=o,l[2]=d,l[3]=o,l[4]=C,l[5]=h,l[6]=d,l[7]=h,l[8]=u;var m=Matrix3.computeEigenDecomposition(l,scratchEigenResult),f=Matrix3.clone(m.unitary,a.halfAxes),x=Matrix3.getColumn(f,0,scratchCartesian4),p=Matrix3.getColumn(f,1,scratchCartesian5),g=Matrix3.getColumn(f,2,scratchCartesian6),P=-Number.MAX_VALUE,M=-Number.MAX_VALUE,w=-Number.MAX_VALUE,B=Number.MAX_VALUE,O=Number.MAX_VALUE,v=Number.MAX_VALUE;for(r=0;r<t;r++)s=e[r],P=Math.max(Cartesian3.dot(x,s),P),M=Math.max(Cartesian3.dot(p,s),M),w=Math.max(Cartesian3.dot(g,s),w),B=Math.min(Cartesian3.dot(x,s),B),O=Math.min(Cartesian3.dot(p,s),O),v=Math.min(Cartesian3.dot(g,s),v);x=Cartesian3.multiplyByScalar(x,.5*(B+P),x),p=Cartesian3.multiplyByScalar(p,.5*(O+M),p),g=Cartesian3.multiplyByScalar(g,.5*(v+w),g);var N=Cartesian3.add(x,p,a.center);Cartesian3.add(N,g,N);var E=scratchCartesian3;return E.x=P-B,E.y=M-O,E.z=w-v,Cartesian3.multiplyByScalar(E,.5,E),Matrix3.multiplyByScale(a.halfAxes,E,a.halfAxes),a};var scratchOffset=new Cartesian3,scratchScale=new Cartesian3;function fromPlaneExtents(e,a,r,t,n,i,s,c,o,d,C){if(!defined(n)||!defined(i)||!defined(s)||!defined(c)||!defined(o)||!defined(d))throw new DeveloperError("all extents (minimum/maximum X/Y/Z) are required.");defined(C)||(C=new OrientedBoundingBox);var h=C.halfAxes;Matrix3.setColumn(h,0,a,h),Matrix3.setColumn(h,1,r,h),Matrix3.setColumn(h,2,t,h);var u=scratchOffset;u.x=(n+i)/2,u.y=(s+c)/2,u.z=(o+d)/2;var l=scratchScale;l.x=(i-n)/2,l.y=(c-s)/2,l.z=(d-o)/2;var m=C.center;return u=Matrix3.multiplyByVector(h,u,u),Cartesian3.add(e,u,m),Matrix3.multiplyByScale(h,l,h),C}var scratchRectangleCenterCartographic=new Cartographic,scratchRectangleCenter=new Cartesian3,scratchPerimeterCartographicNC=new Cartographic,scratchPerimeterCartographicNW=new Cartographic,scratchPerimeterCartographicCW=new Cartographic,scratchPerimeterCartographicSW=new Cartographic,scratchPerimeterCartographicSC=new Cartographic,scratchPerimeterCartesianNC=new Cartesian3,scratchPerimeterCartesianNW=new Cartesian3,scratchPerimeterCartesianCW=new Cartesian3,scratchPerimeterCartesianSW=new Cartesian3,scratchPerimeterCartesianSC=new Cartesian3,scratchPerimeterProjectedNC=new Cartesian2,scratchPerimeterProjectedNW=new Cartesian2,scratchPerimeterProjectedCW=new Cartesian2,scratchPerimeterProjectedSW=new Cartesian2,scratchPerimeterProjectedSC=new Cartesian2,scratchPlaneOrigin=new Cartesian3,scratchPlaneNormal=new Cartesian3,scratchPlaneXAxis=new Cartesian3,scratchHorizonCartesian=new Cartesian3,scratchHorizonProjected=new Cartesian2,scratchMaxY=new Cartesian3,scratchMinY=new Cartesian3,scratchZ=new Cartesian3,scratchPlane=new Plane(Cartesian3.UNIT_X,0);OrientedBoundingBox.fromRectangle=function(e,a,r,t,n){if(!defined(e))throw new DeveloperError("rectangle is required");if(e.width<0||e.width>CesiumMath.TWO_PI)throw new DeveloperError("Rectangle width must be between 0 and 2*pi");if(e.height<0||e.height>CesiumMath.PI)throw new DeveloperError("Rectangle height must be between 0 and pi");if(defined(t)&&!CesiumMath.equalsEpsilon(t.radii.x,t.radii.y,CesiumMath.EPSILON15))throw new DeveloperError("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");var i,s,c,o,d,C,h;if(a=defaultValue(a,0),r=defaultValue(r,0),t=defaultValue(t,Ellipsoid.WGS84),e.width<=CesiumMath.PI){var u=Rectangle.center(e,scratchRectangleCenterCartographic),l=t.cartographicToCartesian(u,scratchRectangleCenter),m=new EllipsoidTangentPlane(l,t);h=m.plane;var f=u.longitude,x=e.south<0&&e.north>0?0:u.latitude,p=Cartographic.fromRadians(f,e.north,r,scratchPerimeterCartographicNC),g=Cartographic.fromRadians(e.west,e.north,r,scratchPerimeterCartographicNW),P=Cartographic.fromRadians(e.west,x,r,scratchPerimeterCartographicCW),M=Cartographic.fromRadians(e.west,e.south,r,scratchPerimeterCartographicSW),w=Cartographic.fromRadians(f,e.south,r,scratchPerimeterCartographicSC),B=t.cartographicToCartesian(p,scratchPerimeterCartesianNC),O=t.cartographicToCartesian(g,scratchPerimeterCartesianNW),v=t.cartographicToCartesian(P,scratchPerimeterCartesianCW),N=t.cartographicToCartesian(M,scratchPerimeterCartesianSW),E=t.cartographicToCartesian(w,scratchPerimeterCartesianSC),y=m.projectPointToNearestOnPlane(B,scratchPerimeterProjectedNC),b=m.projectPointToNearestOnPlane(O,scratchPerimeterProjectedNW),R=m.projectPointToNearestOnPlane(v,scratchPerimeterProjectedCW),S=m.projectPointToNearestOnPlane(N,scratchPerimeterProjectedSW),j=m.projectPointToNearestOnPlane(E,scratchPerimeterProjectedSC);return s=-(i=Math.min(b.x,R.x,S.x)),o=Math.max(b.y,y.y),c=Math.min(S.y,j.y),g.height=M.height=a,O=t.cartographicToCartesian(g,scratchPerimeterCartesianNW),N=t.cartographicToCartesian(M,scratchPerimeterCartesianSW),d=Math.min(Plane.getPointDistance(h,O),Plane.getPointDistance(h,N)),C=r,fromPlaneExtents(m.origin,m.xAxis,m.yAxis,m.zAxis,i,s,c,o,d,C,n)}var W=e.south>0,A=e.north<0,T=W?e.south:A?e.north:0,I=Rectangle.center(e,scratchRectangleCenterCartographic).longitude,z=Cartesian3.fromRadians(I,T,r,t,scratchPlaneOrigin);z.z=0;var D=Math.abs(z.x)<CesiumMath.EPSILON10&&Math.abs(z.y)<CesiumMath.EPSILON10?Cartesian3.UNIT_X:Cartesian3.normalize(z,scratchPlaneNormal),L=Cartesian3.UNIT_Z,V=Cartesian3.cross(D,L,scratchPlaneXAxis);h=Plane.fromPointNormal(z,D,scratchPlane);var U=Cartesian3.fromRadians(I+CesiumMath.PI_OVER_TWO,T,r,t,scratchHorizonCartesian);i=-(s=Cartesian3.dot(Plane.projectPointOntoPlane(h,U,scratchHorizonProjected),V)),o=Cartesian3.fromRadians(0,e.north,A?a:r,t,scratchMaxY).z,c=Cartesian3.fromRadians(0,e.south,W?a:r,t,scratchMinY).z;var q=Cartesian3.fromRadians(e.east,T,r,t,scratchZ);return fromPlaneExtents(z,V,L,D,i,s,c,o,d=Plane.getPointDistance(h,q),C=0,n)},OrientedBoundingBox.clone=function(e,a){if(defined(e))return defined(a)?(Cartesian3.clone(e.center,a.center),Matrix3.clone(e.halfAxes,a.halfAxes),a):new OrientedBoundingBox(e.center,e.halfAxes)},OrientedBoundingBox.intersectPlane=function(e,a){if(!defined(e))throw new DeveloperError("box is required.");if(!defined(a))throw new DeveloperError("plane is required.");var r=e.center,t=a.normal,n=e.halfAxes,i=t.x,s=t.y,c=t.z,o=Math.abs(i*n[Matrix3.COLUMN0ROW0]+s*n[Matrix3.COLUMN0ROW1]+c*n[Matrix3.COLUMN0ROW2])+Math.abs(i*n[Matrix3.COLUMN1ROW0]+s*n[Matrix3.COLUMN1ROW1]+c*n[Matrix3.COLUMN1ROW2])+Math.abs(i*n[Matrix3.COLUMN2ROW0]+s*n[Matrix3.COLUMN2ROW1]+c*n[Matrix3.COLUMN2ROW2]),d=Cartesian3.dot(t,r)+a.distance;return d<=-o?Intersect.OUTSIDE:d>=o?Intersect.INSIDE:Intersect.INTERSECTING};var scratchCartesianU=new Cartesian3,scratchCartesianV=new Cartesian3,scratchCartesianW=new Cartesian3,scratchPPrime=new Cartesian3;OrientedBoundingBox.distanceSquaredTo=function(e,a){if(!defined(e))throw new DeveloperError("box is required.");if(!defined(a))throw new DeveloperError("cartesian is required.");var r=Cartesian3.subtract(a,e.center,scratchOffset),t=e.halfAxes,n=Matrix3.getColumn(t,0,scratchCartesianU),i=Matrix3.getColumn(t,1,scratchCartesianV),s=Matrix3.getColumn(t,2,scratchCartesianW),c=Cartesian3.magnitude(n),o=Cartesian3.magnitude(i),d=Cartesian3.magnitude(s);Cartesian3.normalize(n,n),Cartesian3.normalize(i,i),Cartesian3.normalize(s,s);var C=scratchPPrime;C.x=Cartesian3.dot(r,n),C.y=Cartesian3.dot(r,i),C.z=Cartesian3.dot(r,s);var h,u=0;return C.x<-c?u+=(h=C.x+c)*h:C.x>c&&(u+=(h=C.x-c)*h),C.y<-o?u+=(h=C.y+o)*h:C.y>o&&(u+=(h=C.y-o)*h),C.z<-d?u+=(h=C.z+d)*h:C.z>d&&(u+=(h=C.z-d)*h),u};var scratchCorner=new Cartesian3,scratchToCenter=new Cartesian3;OrientedBoundingBox.computePlaneDistances=function(e,a,r,t){if(!defined(e))throw new DeveloperError("box is required.");if(!defined(a))throw new DeveloperError("position is required.");if(!defined(r))throw new DeveloperError("direction is required.");defined(t)||(t=new Interval);var n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,s=e.center,c=e.halfAxes,o=Matrix3.getColumn(c,0,scratchCartesianU),d=Matrix3.getColumn(c,1,scratchCartesianV),C=Matrix3.getColumn(c,2,scratchCartesianW),h=Cartesian3.add(o,d,scratchCorner);Cartesian3.add(h,C,h),Cartesian3.add(h,s,h);var u=Cartesian3.subtract(h,a,scratchToCenter),l=Cartesian3.dot(r,u);return n=Math.min(l,n),i=Math.max(l,i),Cartesian3.add(s,o,h),Cartesian3.add(h,d,h),Cartesian3.subtract(h,C,h),Cartesian3.subtract(h,a,u),l=Cartesian3.dot(r,u),n=Math.min(l,n),i=Math.max(l,i),Cartesian3.add(s,o,h),Cartesian3.subtract(h,d,h),Cartesian3.add(h,C,h),Cartesian3.subtract(h,a,u),l=Cartesian3.dot(r,u),n=Math.min(l,n),i=Math.max(l,i),Cartesian3.add(s,o,h),Cartesian3.subtract(h,d,h),Cartesian3.subtract(h,C,h),Cartesian3.subtract(h,a,u),l=Cartesian3.dot(r,u),n=Math.min(l,n),i=Math.max(l,i),Cartesian3.subtract(s,o,h),Cartesian3.add(h,d,h),Cartesian3.add(h,C,h),Cartesian3.subtract(h,a,u),l=Cartesian3.dot(r,u),n=Math.min(l,n),i=Math.max(l,i),Cartesian3.subtract(s,o,h),Cartesian3.add(h,d,h),Cartesian3.subtract(h,C,h),Cartesian3.subtract(h,a,u),l=Cartesian3.dot(r,u),n=Math.min(l,n),i=Math.max(l,i),Cartesian3.subtract(s,o,h),Cartesian3.subtract(h,d,h),Cartesian3.add(h,C,h),Cartesian3.subtract(h,a,u),l=Cartesian3.dot(r,u),n=Math.min(l,n),i=Math.max(l,i),Cartesian3.subtract(s,o,h),Cartesian3.subtract(h,d,h),Cartesian3.subtract(h,C,h),Cartesian3.subtract(h,a,u),l=Cartesian3.dot(r,u),n=Math.min(l,n),i=Math.max(l,i),t.start=n,t.stop=i,t};var scratchBoundingSphere=new BoundingSphere;OrientedBoundingBox.isOccluded=function(e,a){if(!defined(e))throw new DeveloperError("box is required.");if(!defined(a))throw new DeveloperError("occluder is required.");var r=BoundingSphere.fromOrientedBoundingBox(e,scratchBoundingSphere);return!a.isBoundingSphereVisible(r)},OrientedBoundingBox.prototype.intersectPlane=function(e){return OrientedBoundingBox.intersectPlane(this,e)},OrientedBoundingBox.prototype.distanceSquaredTo=function(e){return OrientedBoundingBox.distanceSquaredTo(this,e)},OrientedBoundingBox.prototype.computePlaneDistances=function(e,a,r){return OrientedBoundingBox.computePlaneDistances(this,e,a,r)},OrientedBoundingBox.prototype.isOccluded=function(e){return OrientedBoundingBox.isOccluded(this,e)},OrientedBoundingBox.equals=function(e,a){return e===a||defined(e)&&defined(a)&&Cartesian3.equals(e.center,a.center)&&Matrix3.equals(e.halfAxes,a.halfAxes)},OrientedBoundingBox.prototype.clone=function(e){return OrientedBoundingBox.clone(this,e)},OrientedBoundingBox.prototype.equals=function(e){return OrientedBoundingBox.equals(this,e)};export default OrientedBoundingBox;