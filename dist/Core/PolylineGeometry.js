import ArcType from"./ArcType.js";import arrayRemoveDuplicates from"./arrayRemoveDuplicates.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian3 from"./Cartesian3.js";import Color from"./Color.js";import ComponentDatatype from"./ComponentDatatype.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import Geometry from"./Geometry.js";import GeometryAttribute from"./GeometryAttribute.js";import GeometryAttributes from"./GeometryAttributes.js";import GeometryType from"./GeometryType.js";import IndexDatatype from"./IndexDatatype.js";import CesiumMath from"./Math.js";import PolylinePipeline from"./PolylinePipeline.js";import PrimitiveType from"./PrimitiveType.js";import VertexFormat from"./VertexFormat.js";var scratchInterpolateColorsArray=[];function interpolateColors(e,r,t,o,a){var i,n=scratchInterpolateColorsArray;n.length=a;var l=t.red,s=t.green,p=t.blue,c=t.alpha,m=o.red,d=o.green,y=o.blue,h=o.alpha;if(Color.equals(t,o)){for(i=0;i<a;i++)n[i]=Color.clone(t);return n}var u=(m-l)/a,f=(d-s)/a,v=(y-p)/a,C=(h-c)/a;for(i=0;i<a;i++)n[i]=new Color(l+i*u,s+i*f,p+i*v,c+i*C);return n}function PolylineGeometry(e){var r=(e=defaultValue(e,defaultValue.EMPTY_OBJECT)).positions,t=e.colors,o=defaultValue(e.width,1),a=defaultValue(e.colorsPerVertex,!1);if(!defined(r)||r.length<2)throw new DeveloperError("At least two positions are required.");if("number"!==typeof o)throw new DeveloperError("width must be a number");if(defined(t)&&(a&&t.length<r.length||!a&&t.length<r.length-1))throw new DeveloperError("colors has an invalid length.");this._positions=r,this._colors=t,this._width=o,this._colorsPerVertex=a,this._vertexFormat=VertexFormat.clone(defaultValue(e.vertexFormat,VertexFormat.DEFAULT)),this._arcType=defaultValue(e.arcType,ArcType.GEODESIC),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";var i=1+r.length*Cartesian3.packedLength;i+=defined(t)?1+t.length*Color.packedLength:1,this.packedLength=i+Ellipsoid.packedLength+VertexFormat.packedLength+4}PolylineGeometry.pack=function(e,r,t){if(!defined(e))throw new DeveloperError("value is required");if(!defined(r))throw new DeveloperError("array is required");var o;t=defaultValue(t,0);var a=e._positions,i=a.length;for(r[t++]=i,o=0;o<i;++o,t+=Cartesian3.packedLength)Cartesian3.pack(a[o],r,t);var n=e._colors;for(i=defined(n)?n.length:0,r[t++]=i,o=0;o<i;++o,t+=Color.packedLength)Color.pack(n[o],r,t);return Ellipsoid.pack(e._ellipsoid,r,t),t+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,r,t),t+=VertexFormat.packedLength,r[t++]=e._width,r[t++]=e._colorsPerVertex?1:0,r[t++]=e._arcType,r[t]=e._granularity,r};var scratchEllipsoid=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat=new VertexFormat,scratchOptions={positions:void 0,colors:void 0,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};PolylineGeometry.unpack=function(e,r,t){if(!defined(e))throw new DeveloperError("array is required");var o;r=defaultValue(r,0);var a=e[r++],i=new Array(a);for(o=0;o<a;++o,r+=Cartesian3.packedLength)i[o]=Cartesian3.unpack(e,r);var n=(a=e[r++])>0?new Array(a):void 0;for(o=0;o<a;++o,r+=Color.packedLength)n[o]=Color.unpack(e,r);var l=Ellipsoid.unpack(e,r,scratchEllipsoid);r+=Ellipsoid.packedLength;var s=VertexFormat.unpack(e,r,scratchVertexFormat);r+=VertexFormat.packedLength;var p=e[r++],c=1===e[r++],m=e[r++],d=e[r];return defined(t)?(t._positions=i,t._colors=n,t._ellipsoid=Ellipsoid.clone(l,t._ellipsoid),t._vertexFormat=VertexFormat.clone(s,t._vertexFormat),t._width=p,t._colorsPerVertex=c,t._arcType=m,t._granularity=d,t):(scratchOptions.positions=i,scratchOptions.colors=n,scratchOptions.width=p,scratchOptions.colorsPerVertex=c,scratchOptions.arcType=m,scratchOptions.granularity=d,new PolylineGeometry(scratchOptions))};var scratchCartesian3=new Cartesian3,scratchPosition=new Cartesian3,scratchPrevPosition=new Cartesian3,scratchNextPosition=new Cartesian3;PolylineGeometry.createGeometry=function(e){var r,t,o,a=e._width,i=e._vertexFormat,n=e._colors,l=e._colorsPerVertex,s=e._arcType,p=e._granularity,c=e._ellipsoid,m=arrayRemoveDuplicates(e._positions,Cartesian3.equalsEpsilon),d=m.length;if(!(d<2||a<=0)){if(s===ArcType.GEODESIC||s===ArcType.RHUMB){var y,h;s===ArcType.GEODESIC?(y=CesiumMath.chordLength(p,c.maximumRadius),h=PolylinePipeline.numberOfPoints):(y=p,h=PolylinePipeline.numberOfPointsRhumbLine);var u=PolylinePipeline.extractHeights(m,c);if(defined(n)){var f=1;for(r=0;r<d-1;++r)f+=h(m[r],m[r+1],y);var v=new Array(f),C=0;for(r=0;r<d-1;++r){var P=m[r],g=m[r+1],E=n[r],A=h(P,g,y);if(l&&r<f){var w=interpolateColors(P,g,E,n[r+1],A),x=w.length;for(t=0;t<x;++t)v[C++]=w[t]}else for(t=0;t<A;++t)v[C++]=Color.clone(E)}v[C]=Color.clone(n[n.length-1]),n=v,scratchInterpolateColorsArray.length=0}m=s===ArcType.GEODESIC?PolylinePipeline.generateCartesianArc({positions:m,minDistance:y,ellipsoid:c,height:u}):PolylinePipeline.generateCartesianRhumbArc({positions:m,granularity:y,ellipsoid:c,height:u})}var D,_=4*(d=m.length)-4,T=new Float64Array(3*_),G=new Float64Array(3*_),V=new Float64Array(3*_),b=new Float32Array(2*_),F=i.st?new Float32Array(2*_):void 0,k=defined(n)?new Uint8Array(4*_):void 0,L=0,O=0,j=0,I=0;for(t=0;t<d;++t){var S,B;0===t?(D=scratchCartesian3,Cartesian3.subtract(m[0],m[1],D),Cartesian3.add(m[0],D,D)):D=m[t-1],Cartesian3.clone(D,scratchPrevPosition),Cartesian3.clone(m[t],scratchPosition),t===d-1?(D=scratchCartesian3,Cartesian3.subtract(m[d-1],m[d-2],D),Cartesian3.add(m[d-1],D,D)):D=m[t+1],Cartesian3.clone(D,scratchNextPosition),defined(k)&&(S=0===t||l?n[t]:n[t-1],t!==d-1&&(B=n[t]));var R=t===d-1?2:4;for(o=0===t?2:0;o<R;++o){Cartesian3.pack(scratchPosition,T,L),Cartesian3.pack(scratchPrevPosition,G,L),Cartesian3.pack(scratchNextPosition,V,L),L+=3;var N=o-2<0?-1:1;if(b[O++]=o%2*2-1,b[O++]=N*a,i.st&&(F[j++]=t/(d-1),F[j++]=Math.max(b[O-2],0)),defined(k)){var U=o<2?S:B;k[I++]=Color.floatToByte(U.red),k[I++]=Color.floatToByte(U.green),k[I++]=Color.floatToByte(U.blue),k[I++]=Color.floatToByte(U.alpha)}}}var M=new GeometryAttributes;M.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:T}),M.prevPosition=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),M.nextPosition=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:V}),M.expandAndWidth=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:b}),i.st&&(M.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:F})),defined(k)&&(M.color=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:k,normalize:!0}));var q=IndexDatatype.createTypedArray(_,6*d-6),H=0,Y=0,W=d-1;for(t=0;t<W;++t)q[Y++]=H,q[Y++]=H+2,q[Y++]=H+1,q[Y++]=H+1,q[Y++]=H+2,q[Y++]=H+3,H+=4;return new Geometry({attributes:M,indices:q,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:BoundingSphere.fromPoints(m),geometryType:GeometryType.POLYLINES})}};export default PolylineGeometry;