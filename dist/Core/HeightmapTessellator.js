import AxisAlignedBoundingBox from"./AxisAlignedBoundingBox.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian2 from"./Cartesian2.js";import Cartesian3 from"./Cartesian3.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import EllipsoidalOccluder from"./EllipsoidalOccluder.js";import CesiumMath from"./Math.js";import Matrix4 from"./Matrix4.js";import OrientedBoundingBox from"./OrientedBoundingBox.js";import Rectangle from"./Rectangle.js";import TerrainEncoding from"./TerrainEncoding.js";import Transforms from"./Transforms.js";import WebMercatorProjection from"./WebMercatorProjection.js";var HeightmapTessellator={};HeightmapTessellator.DEFAULT_STRUCTURE=Object.freeze({heightScale:1,heightOffset:0,elementsPerHeight:1,stride:1,elementMultiplier:256,isBigEndian:!1});var cartesian3Scratch=new Cartesian3,matrix4Scratch=new Matrix4,minimumScratch=new Cartesian3,maximumScratch=new Cartesian3;HeightmapTessellator.computeVertices=function(e){if(!defined(e)||!defined(e.heightmap))throw new DeveloperError("options.heightmap is required.");if(!defined(e.width)||!defined(e.height))throw new DeveloperError("options.width and options.height are required.");if(!defined(e.nativeRectangle))throw new DeveloperError("options.nativeRectangle is required.");if(!defined(e.skirtHeight))throw new DeveloperError("options.skirtHeight is required.");var r,t,i,a,o=Math.cos,n=Math.sin,s=Math.sqrt,l=Math.atan,m=Math.exp,d=CesiumMath.PI_OVER_TWO,u=CesiumMath.toRadians,h=e.heightmap,c=e.width,g=e.height,p=e.skirtHeight,f=defaultValue(e.isGeographic,!0),T=defaultValue(e.ellipsoid,Ellipsoid.WGS84),E=1/T.maximumRadius,v=e.nativeRectangle,I=e.rectangle;defined(I)?(r=I.west,t=I.south,i=I.east,a=I.north):f?(r=u(v.west),t=u(v.south),i=u(v.east),a=u(v.north)):(r=v.west*E,t=d-2*l(m(-v.south*E)),i=v.east*E,a=d-2*l(m(-v.north*E)));var S=e.relativeToCenter,x=defined(S);S=x?S:Cartesian3.ZERO;var M=defaultValue(e.exaggeration,1),w=defaultValue(e.includeWebMercatorT,!1),C=defaultValue(e.structure,HeightmapTessellator.DEFAULT_STRUCTURE),R=defaultValue(C.heightScale,HeightmapTessellator.DEFAULT_STRUCTURE.heightScale),U=defaultValue(C.heightOffset,HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset),A=defaultValue(C.elementsPerHeight,HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight),N=defaultValue(C.stride,HeightmapTessellator.DEFAULT_STRUCTURE.stride),B=defaultValue(C.elementMultiplier,HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier),j=defaultValue(C.isBigEndian,HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian),V=Rectangle.computeWidth(v),H=Rectangle.computeHeight(v),F=V/(c-1),P=H/(g-1);f||(V*=E,H*=E);var O,_,b=T.radiiSquared,D=b.x,y=b.y,L=b.z,W=65536,Y=-65536,q=Transforms.eastNorthUpToFixedFrame(S,T),z=Matrix4.inverseTransformation(q,matrix4Scratch);w&&(O=WebMercatorProjection.geodeticLatitudeToMercatorAngle(t),_=1/(WebMercatorProjection.geodeticLatitudeToMercatorAngle(a)-O));var G=minimumScratch;G.x=Number.POSITIVE_INFINITY,G.y=Number.POSITIVE_INFINITY,G.z=Number.POSITIVE_INFINITY;var k=maximumScratch;k.x=Number.NEGATIVE_INFINITY,k.y=Number.NEGATIVE_INFINITY,k.z=Number.NEGATIVE_INFINITY;var Z=Number.POSITIVE_INFINITY,J=c*g,K=J+(p>0?2*c+2*g:0),Q=new Array(K),X=new Array(K),$=new Array(K),ee=w?new Array(K):[],re=0,te=g,ie=0,ae=c;p>0&&(--re,++te,--ie,++ae);for(var oe=1e-5,ne=re;ne<te;++ne){var se=ne;se<0&&(se=0),se>=g&&(se=g-1);var le=v.north-P*se,me=((le=f?u(le):d-2*l(m(-le*E)))-t)/(a-t);me=CesiumMath.clamp(me,0,1);var de=ne===re,ue=ne===te-1;p>0&&(de?le+=oe*H:ue&&(le-=oe*H));var he,ce=o(le),ge=n(le),pe=L*ge;w&&(he=(WebMercatorProjection.geodeticLatitudeToMercatorAngle(le)-O)*_);for(var fe=ie;fe<ae;++fe){var Te=fe;Te<0&&(Te=0),Te>=c&&(Te=c-1);var Ee,ve,Ie=se*(c*N)+Te*N;if(1===A)Ee=h[Ie];else if(Ee=0,j)for(ve=0;ve<A;++ve)Ee=Ee*B+h[Ie+ve];else for(ve=A-1;ve>=0;--ve)Ee=Ee*B+h[Ie+ve];Ee=(Ee*R+U)*M,Y=Math.max(Y,Ee),W=Math.min(W,Ee);var Se=v.west+F*Te;f?Se=u(Se):Se*=E;var xe=(Se-r)/(i-r);xe=CesiumMath.clamp(xe,0,1);var Me=se*c+Te;if(p>0){var we=fe===ie,Ce=fe===ae-1,Re=de||ue||we||Ce;if((de||ue)&&(we||Ce))continue;Re&&(Ee-=p,we?(Me=J+(g-se-1),Se-=oe*V):ue?Me=J+g+(c-Te-1):Ce?(Me=J+g+c+se,Se+=oe*V):de&&(Me=J+g+c+g+Te))}var Ue=ce*o(Se),Ae=ce*n(Se),Ne=D*Ue,Be=y*Ae,je=1/s(Ne*Ue+Be*Ae+pe*ge),Ve=Ne*je,He=Be*je,Fe=pe*je,Pe=new Cartesian3;Pe.x=Ve+Ue*Ee,Pe.y=He+Ae*Ee,Pe.z=Fe+ge*Ee,Q[Me]=Pe,X[Me]=Ee,$[Me]=new Cartesian2(xe,me),w&&(ee[Me]=he),Matrix4.multiplyByPoint(z,Pe,cartesian3Scratch),Cartesian3.minimumByComponent(cartesian3Scratch,G,G),Cartesian3.maximumByComponent(cartesian3Scratch,k,k),Z=Math.min(Z,Ee)}}var Oe,_e,be=BoundingSphere.fromPoints(Q);(defined(I)&&(Oe=OrientedBoundingBox.fromRectangle(I,W,Y,T)),x)&&(_e=new EllipsoidalOccluder(T).computeHorizonCullingPointPossiblyUnderEllipsoid(S,Q,W));for(var De=new AxisAlignedBoundingBox(G,k,S),ye=new TerrainEncoding(De,Z,Y,q,!1,w),Le=new Float32Array(K*ye.getStride()),We=0,Ye=0;Ye<K;++Ye)We=ye.encode(Le,We,Q[Ye],$[Ye],X[Ye],void 0,ee[Ye]);return{vertices:Le,maximumHeight:Y,minimumHeight:W,encoding:ye,boundingSphere3D:be,orientedBoundingBox:Oe,occludeePointInScaledSpace:_e}};export default HeightmapTessellator;